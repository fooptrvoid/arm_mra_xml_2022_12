<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MDCR_EL2</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">MDCR_EL2, Monitor Debug Configuration Register (EL2)</h1><p>The MDCR_EL2 characteristics are:</p><h2>Purpose</h2><p>Provides EL2 configuration options for self-hosted debug and the Performance Monitors Extension.</p><h2>Configuration</h2><p>AArch64 System register MDCR_EL2 bits [31:0] are architecturally mapped to AArch32 System register <a href="AArch32-hdcr.html">HDCR[31:0]</a>.</p><p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p><p>This register has no effect if EL2 is not enabled in the current Security state.</p><h2>Attributes</h2><p>MDCR_EL2 is a 64-bit register.</p><h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_0-63_44">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-43_43-1">EBWE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-42_42">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-41_40-1">PMEE</a></td><td class="lr" colspan="3"><a href="#fieldset_0-39_37">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-36_36-1">HPMFZS</a></td><td class="lr" colspan="4"><a href="#fieldset_0-35_32">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="2"><a href="#fieldset_0-31_30-1"><ins class="nocount">PMSSE</ins></a><a href="#fieldset_0-35_30"><del class="nocount">RES0</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29-1">HPMFZO</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28-1">MTPME</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27-1">TDCC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26-1">HLP</a></td><td class="lr" colspan="2"><a href="#fieldset_0-25_24-1">E2TB</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23-1">HCCD</a></td><td class="lr" colspan="3"><a href="#fieldset_0-22_20">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-19_19-1">TTRF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-18_18">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-17_17-1">HPMD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-16_16">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-15_15-1"><ins class="nocount">EnSPM</ins></a><a href="#fieldset_0-14_14-1"><del class="nocount">TPMS</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-14_14-1"><ins class="nocount">TPMS</ins></a><a href="#fieldset_0-13_12-1"><del class="nocount">E2PB</del></a></td><td class="lr" colspan="2"><a href="#fieldset_0-13_12-1"><ins class="nocount">E2PB</ins></a><a href="#fieldset_0-11_11"><del class="nocount">TDRA</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11"><ins class="nocount">TDRA</ins></a><a href="#fieldset_0-10_10-1"><del class="nocount">TDOSA</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10-1"><ins class="nocount">TDOSA</ins></a><a href="#fieldset_0-9_9"><del class="nocount">TDA</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9"><ins class="nocount">TDA</ins></a><a href="#fieldset_0-8_8"><del class="nocount">TDE</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8"><ins class="nocount">TDE</ins></a><a href="#fieldset_0-7_7-1"><del class="nocount">HPME</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7-1"><ins class="nocount">HPME</ins></a><a href="#fieldset_0-6_6-1"><del class="nocount">TPM</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6-1"><ins class="nocount">TPM</ins></a><a href="#fieldset_0-5_5-1"><del class="nocount">TPMCR</del></a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5-1"><ins class="nocount">TPMCR</ins></a><a href="#fieldset_0-4_0-1"><del class="nocount">HPMN</del></a></td><td class="lr" colspan="5"><a href="#fieldset_0-4_0-1"><ins class="nocount">HPMN</ins></a></td></tr></tbody></table><h4 id="fieldset_0-63_44">Bits [63:44]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-43_43-1">EBWE, bit [43]<span class="condition"><br/>When FEAT_Debugv8p9 is implemented:
                        </span></h4><div class="field"><p>Extended Breakpoint and Watchpoint Enable. Enables use of additional breakpoints or watchpoints.</p><table class="valuetable"><tr><th>EBWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Effective value of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.EBWE is 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Effective value of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.EBWE is not affected by this <ins>field.</ins><del>bit.</del></p></td></tr></table><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this field is implemented or is <span class="arm-defined-word">RES0</span> when 16 or fewer breakpoints are implemented, 16 or fewer watchpoints are implemented, and <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a> is implemented as RAZ/WI.</p><p>If EL2 is not implemented or EL2 is disabled in the current Security state, then the Effective value of this field is 1, other than for a direct read of the register.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-43_43-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-42_42">Bit [42]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-41_40-1">PMEE, bits [41:40]<span class="condition"><br/>When FEAT_EBEP is implemented:
                        </span></h4><div class="field"><p>Performance Monitors Exception Enable. Controls the generation of <span class="signal">PMUIRQ</span> signal and PMU exception at EL0, EL1, and EL2.</p><table class="valuetable"><tr><th>PMEE</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p><span class="signal">PMUIRQ</span> signal is enabled, and PMU exception is disabled.</p></td></tr><tr><td class="bitfield">0b01</td><td><p><span class="signal">PMUIRQ</span> signal and PMU exception are both controlled by <a href="AArch64-pmecr_el1.html">PMECR_EL1</a>.PMEE.</p></td></tr><tr><td class="bitfield">0b10</td><td><p><span class="signal">PMUIRQ</span> signal is disabled, and PMU exception is disabled.</p></td></tr><tr><td class="bitfield">0b11</td><td><p><span class="signal">PMUIRQ</span> signal is disabled, and PMU exception is enabled.</p></td></tr></table><p>If EL2 is not implemented or EL2 is disabled in the current Security state, then the Effective value of this field is <span class="binarynumber">0b01</span>, other than for a direct read of the register.</p><p>This field is ignored by the PE when all of the following are true:</p><ul><li>EL3 is implemented.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.PMEE != <span class="binarynumber">0b01</span>.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-41_40-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-39_37">Bits [39:37]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-36_36-1">HPMFZS, bit [36]<span class="condition"><br/>When FEAT_SPEv1p2 is implemented:
                        </span></h4><div class="field"><p>Hyp Performance Monitors Freeze-on-SPE event. Stop counters when <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a>.{PMFZ, E} == {1, 1} and <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.S == 1.</p><table class="valuetable"><tr><th>HPMFZS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Do not freeze on Statistical Profiling Buffer Management event.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Affected</ins><del>Event</del> counters do not count following a Statistical Profiling Buffer Management event.</p></td></tr></table><p><ins>The</ins><del>If</del> <ins>counters</ins><del>MDCR_EL2.HPMN</del> <ins>affected</ins><del>is</del> <ins>by</ins><del>less</del> <ins>this field are event counters</ins><del>than</del> <a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a> <ins>for</ins><del>.N,</del> <ins>values</ins><del>this</del> <del>field affects the operation </del>of <ins>n</ins><del>event</del> <ins>greater</ins><del>counters</del> <ins>than</ins><del>in</del> <ins>or</ins><del>the</del> <ins>equal</ins><del>range</del> <ins>to </ins><del>[</del>MDCR_EL2.HPMN <ins>and</ins><del>..</del> <ins>less than</ins><del>(</del> <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.<ins>N. This applies even when EL2 is disabled in the current Security state.</ins><del>N-1)].</del></p><p><ins>Other</ins><del>This</del> <del>field does not affect the operation of other </del>event counters<ins>,</ins><del> and</del> <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a><ins>, and, if</ins><del>.</del> <span class="xref"><ins>FEAT_PMUv3_ICNTR</ins></span><ins> is implemented, </ins><a href="AArch64-pmicntr_el0.html"><ins>PMICNTR_EL0</ins></a><ins> are not affected by this field.</ins></p><p><ins>If</ins><del>The</del> <ins>MDCR_EL2.HPMN</ins><del>operation</del> <del>of this field applies even when EL2 </del>is <ins>equal</ins><del>disabled</del> <ins>to</ins><del>in the current Security state.</del> <a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.N, then this field has no effect.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-36_36-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-35_32">Bits [35:<ins>32</ins><del>30</del>]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-31_30-1"><ins>PMSSE, bits [31:30]</ins><span class="condition"><br/><ins>When FEAT_PMUv3_SS is implemented:
                        </ins></span></h4><div class="field"><p><ins>Performance Monitors Snapshot Enable. Controls the generation of Capture events.</ins></p><table class="valuetable"><tr><th><ins>PMSSE</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b00</ins></td><td><p><ins>Capture events are disabled.</ins></p></td></tr><tr><td class="bitfield"><ins>0b01</ins></td><td><p><ins>Capture events are controlled by </ins><a href="AArch64-pmecr_el1.html"><ins>PMECR_EL1</ins></a><ins>.SSE.</ins></p></td></tr><tr><td class="bitfield"><ins>0b10</ins></td><td><p><ins>Capture events are enabled and prohibited.</ins></p></td></tr><tr><td class="bitfield"><ins>0b11</ins></td><td><p><ins>Capture events are enabled and allowed.</ins></p></td></tr></table><p><ins>If EL2 is not implemented or EL2 is disabled in the current Security state, then the Effective value of this field is </ins><span class="binarynumber"><ins>0b01</ins></span><ins>, other than for a direct read of the register.</ins></p><p><ins>The reset behavior of this field is:</ins></p><ul><li><ins>On a Warm reset, 
      this field resets
       to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></li></ul></div><h4 id="fieldset_0-31_30-2"><span class="condition"><br/><ins>Otherwise:
                        </ins></span></h4><div class="field"><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-29_29-1">HPMFZO, bit [29]<span class="condition"><br/>When FEAT_PMUv3p7 is implemented:
                        </span></h4><div class="field"><p>Hyp Performance Monitors Freeze-on-overflow. Stop event counters on overflow.</p><table class="valuetable"><tr><th>HPMFZO</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Do not freeze on overflow.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Affected</ins><del>Event</del> counters do not count when <a href="AArch64-pmovsclr_el0.html">PMOVSCLR_EL0</a>[(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1):MDCR_EL2.HPMN] is nonzero.</p></td></tr></table><p><ins>The</ins><del>If</del> <ins>counters</ins><del>MDCR_EL2.HPMN</del> <ins>affected</ins><del>is</del> <ins>by</ins><del>less</del> <ins>this field are event counters</ins><del>than</del> <a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a> <ins>for</ins><del>.N,</del> <ins>values</ins><del>this</del> <del>field affects the operation </del>of <ins>n</ins><del>event</del> <ins>greater</ins><del>counters</del> <ins>than</ins><del>in</del> <ins>or</ins><del>the</del> <ins>equal</ins><del>range</del> <ins>to </ins><del>[</del>MDCR_EL2.HPMN <ins>and</ins><del>..</del> <ins>less than</ins><del>(</del> <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.<ins>N. This applies even when EL2 is disabled in the current Security state.</ins><del>N-1)].</del></p><p><ins>Other</ins><del>This</del> <del>field does not affect the operation of other </del>event counters<ins>,</ins><del> and</del> <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a><ins>, and, if</ins><del>.</del> <span class="xref"><ins>FEAT_PMUv3_ICNTR</ins></span><ins> is implemented, </ins><a href="AArch64-pmicntr_el0.html"><ins>PMICNTR_EL0</ins></a><ins> are not affected by this field.</ins></p><p><ins>If</ins><del>The</del> <ins>MDCR_EL2.HPMN</ins><del>operation</del> <del>of this field applies even when EL2 </del>is <ins>equal</ins><del>disabled</del> <ins>to</ins><del>in the current Security state.</del> <a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.N, then this field has no effect.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-28_28-1">MTPME, bit [28]<span class="condition"><br/>When FEAT_MTPMU is implemented and EL3 is not implemented:
                        </span></h4><div class="field"><p>Multi-threaded PMU Enable. Enables use of the <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n>_EL0</a>.MT bits.</p><table class="valuetable"><tr><th>MTPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="xref">FEAT_MTPMU</span> is disabled. The Effective value of <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n>_EL0</a>.MT is zero.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n>_EL0</a>.MT bits not affected by this field.</p></td></tr></table><p>If <span class="xref">FEAT_MTPMU</span> is disabled for any other PE in the system that has the same level 1 Affinity as the PE, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the PE behaves as if this field is 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to <span class="binarynumber">1</span>.
</li></ul></div><h4 id="fieldset_0-28_28-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-27_27-1">TDCC, bit [27]<span class="condition"><br/>When FEAT_FGT is implemented:
                        </span></h4><div class="field"><p>Trap DCC. Traps use of the Debug Comms Channel at EL1 and EL0 to EL2.</p><table class="valuetable"><tr><th>TDCC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any register accesses to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, accesses to the DCC registers at EL1 and EL0 generate a Trap exception to EL2, unless the access also generates a higher priority exception.</p><p>Traps on the DCC data transfer registers are ignored when the PE is in Debug state.</p></td></tr></table><p>The DCC registers trapped by this control are:</p><p>AArch64: <a href="AArch64-osdtrrx_el1.html">OSDTRRX_EL1</a>, <a href="AArch64-osdtrtx_el1.html">OSDTRTX_EL1</a>, <a href="AArch64-mdccsr_el0.html">MDCCSR_EL0</a>, <a href="AArch64-mdccint_el1.html">MDCCINT_EL1</a>, and, when the PE is in Non-debug state, <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a>.</p><p>AArch32: <a href="AArch32-dbgdtrrxext.html">DBGDTRRXext</a>, <a href="AArch32-dbgdtrtxext.html">DBGDTRTXext</a>, <a href="AArch32-dbgdscrint.html">DBGDSCRint</a>, <a href="AArch32-dbgdccint.html">DBGDCCINT</a>, and, when the PE is in Non-debug state, <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p><p>The traps are reported with EC syndrome value:</p><ul><li><span class="hexnumber">0x05</span> for trapped AArch32 <span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses with coproc == <span class="binarynumber">0b1110</span>.
</li><li><span class="hexnumber">0x06</span> for trapped AArch32 <span class="instruction">LDC</span> to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> and <span class="instruction">STC</span> from <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a>.
</li><li><span class="hexnumber">0x18</span> for trapped AArch64 <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses.
</li></ul><p>When the PE is in Debug state, MDCR_EL2.TDCC does not trap any accesses to:</p><p>AArch64: <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a>.</p><p>AArch32: <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-27_27-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-26_26-1">HLP, bit [26]<span class="condition"><br/>When FEAT_PMUv3p5 is implemented:
                        </span></h4><div class="field"><p>Hypervisor Long <ins>Event</ins><del>event</del> <ins>Counter</ins><del>counter</del> <ins>Enable.</ins><del>enable.</del> Determines <ins>which</ins><del>when</del> <ins>event</ins><del>unsigned</del> <ins>counter</ins><del>overflow</del> <ins>bit</ins><del>is</del> <ins>generates</ins><del>recorded</del> <del>by </del>an <del>event counter </del>overflow <ins>recorded by</ins><del>bit.</del> <a href="AArch32-pmovsr.html"><ins>PMOVSR</ins></a><ins>[n].</ins></p><table class="valuetable"><tr><th>HLP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><ins>Affected</ins><del>Event</del> <ins>counters</ins><del>counter</del> overflow on increment that causes unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>[31:0].</p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Affected</ins><del>Event</del> <ins>counters</ins><del>counter</del> overflow on increment that causes unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>[63:0].</p></td></tr></table><p><ins>The</ins><del>If</del> <ins>counters</ins><del>MDCR_EL2.HPMN</del> <ins>affected</ins><del>is</del> <ins>by</ins><del>less</del> <ins>this field are event counters</ins><del>than</del> <a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a> <ins>for</ins><del>.N,</del> <ins>values</ins><del>this</del> <ins>of</ins><del>bit</del> <ins>n</ins><del>affects</del> <ins>greater</ins><del>the</del> <ins>than</ins><del>operation</del> <ins>or</ins><del>of</del> <ins>equal</ins><del>event</del> <ins>to</ins><del>counters</del> <ins>MDCR_EL2.HPMN</ins><del>in</del> <ins>and</ins><del>the</del> <ins>less</ins><del>range</del> <ins>than</ins><del>[MDCR_EL2.HPMN..(</del> <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.<ins>N. This applies even when EL2 is disabled in the current Security state.</ins><del>N-1)].</del></p><p><ins>Other</ins><del>This</del> <del>field does not affect the operation of other </del>event <ins>counters,</ins><del>counters.</del> <a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins>, and, if </ins><span class="xref"><ins>FEAT_PMUv3_ICNTR</ins></span><ins> is implemented, </ins><a href="AArch64-pmicntr_el0.html"><ins>PMICNTR_EL0</ins></a><ins> are not affected by this field.</ins></p><p><ins>If</ins><del>The</del> <ins>MDCR_EL2.HPMN</ins><del>operation</del> <del>of this field applies even when EL2 </del>is <ins>equal</ins><del>disabled</del> <ins>to</ins><del>in the current Security state.</del> <a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.N, then this field has no effect.</ins></p><p><ins>For more information see the description of MDCR_EL2.HPMN.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_26-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-25_24-1">E2TB, bits [25:24]<span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>EL2 Trace Buffer.</p><p>If EL2 is implemented and enabled in the Trace Buffer owning Security state, controls the owning translation regime.</p><p>If EL2 is implemented and enabled in the current Security state, controls access to Trace Buffer control registers from EL1.</p><table class="valuetable"><tr><th>E2TB</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>If EL2 is implemented and enabled in the Trace Buffer owning Security state, <ins>then </ins>the Trace Buffer owning Exception level is EL2. Otherwise, the Trace Buffer owning Exception level is EL1 and, if <span class="function">TraceBufferEnabled</span>() == TRUE, tracing is prohibited at EL2.</p><p>If EL2 is implemented and enabled in the current Security state, accesses to Trace Buffer control registers at EL1 generate a Trap exception to EL2.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Trace Buffer owning Exception level is EL1. If <span class="function">TraceBufferEnabled</span>() == TRUE, <ins>then </ins>tracing is prohibited at EL2.</p><p>If EL2 is implemented and enabled in the current Security state, accesses to Trace Buffer control registers at EL1 generate a Trap exception to EL2.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Trace Buffer owning Exception level is EL1. If <span class="function">TraceBufferEnabled</span>() == TRUE, <ins>then </ins>tracing is prohibited at EL2.</p></td></tr></table><p>All other values are reserved.</p><p><ins>In</ins><del>The</del> <ins>AArch64</ins><del>Trace</del> <ins>state,</ins><del>Buffer</del> <ins>the</ins><del>control</del> <ins>instructions</ins><del>registers</del> <ins>affected</ins><del>trapped</del> by this control are:<a href="AArch64-trbbaser_el1.html"><del>TRBBASER_EL1</del></a><del>, </del><a href="AArch64-trblimitr_el1.html"><del>TRBLIMITR_EL1</del></a><del>, </del><a href="AArch64-trbmar_el1.html"><del>TRBMAR_EL1</del></a><del>, </del><a href="AArch64-trbptr_el1.html"><del>TRBPTR_EL1</del></a><del>, </del><a href="AArch64-trbsr_el1.html"><del>TRBSR_EL1</del></a><del>, and </del><a href="AArch64-trbtrg_el1.html"><del>TRBTRG_EL1</del></a><del>.</del></p><ul><li><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-trbbaser_el1.html"><ins>TRBBASER_EL1</ins></a><ins>, </ins><a href="AArch64-trblimitr_el1.html"><ins>TRBLIMITR_EL1</ins></a><ins>, </ins><a href="AArch64-trbmar_el1.html"><ins>TRBMAR_EL1</ins></a><ins>, </ins><a href="AArch64-trbptr_el1.html"><ins>TRBPTR_EL1</ins></a><ins>, </ins><a href="AArch64-trbsr_el1.html"><ins>TRBSR_EL1</ins></a><ins>, and </ins><a href="AArch64-trbtrg_el1.html"><ins>TRBTRG_EL1</ins></a><ins>.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_TRBE_MPAM</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-trbmpam_el1.html"><ins>TRBMPAM_EL1</ins></a><ins>.
</ins></li></ul><p><ins>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL2.</ins></p><p><ins>Trapped instructions are reported using EC syndrome value </ins><span class="hexnumber"><ins>0x18</ins></span><ins>.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_24-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-23_23-1">HCCD, bit [23]<span class="condition"><br/>When FEAT_PMUv3p5 is implemented:
                        </span></h4><div class="field"><p>Hypervisor Cycle Counter Disable. Prohibits <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> from counting at EL2.</p><table class="valuetable"><tr><th>HCCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is prohibited at EL2.</p></td></tr></table><p>This field does not affect the CPU_CYCLES event or any other event that counts cycles.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-23_23-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-22_20">Bits [22:20]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-19_19-1">TTRF, bit [19]<span class="condition"><br/>When FEAT_TRF is implemented:
                        </span></h4><div class="field"><p>Traps use of the Trace Filter Control registers at EL1 to EL2, as follows:</p><ul><li><p>Access to <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> is trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p></li><li><p>Access to <a href="AArch32-trfcr.html">TRFCR</a> is trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x03</span>.</p></li></ul><table class="valuetable"><tr><th>TTRF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Accesses to the specified registers at EL1 are not affected by this control.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Accesses to the specified registers at EL1 generate a trap exception to EL2 when EL2 is enabled in the current Security state.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-19_19-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-18_18">Bit [18]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-17_17-1">HPMD, bit [17]<span class="condition"><br/>When FEAT_PMUv3p1 is implemented and FEAT_Debugv8p2 is implemented:
                        </span></h4><div class="field"><p>Guest Performance Monitors Disable. Controls <ins>PMU</ins><del>event</del> <ins>operation</ins><del>counting by some event counters</del> at EL2.</p><table class="valuetable"><tr><th>HPMD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><ins>Counters</ins><del>Event</del> <ins>are</ins><del>counting</del> <ins>not affected by this mechanism.</ins><del>and</del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del> are not affected by this mechanism.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Affected</ins><del>Event</del> <del>counting by some event </del>counters <ins>are</ins><del>is</del> prohibited <ins>from counting </ins>at EL2.<del> If</del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.DP is 1, </del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del> is disabled at EL2. Otherwise, </del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del> is not affected by this mechanism.</del></p><p><ins>If </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.DP is 1, then </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins> is disabled at EL2. Otherwise, </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins> is not affected by this mechanism.</ins></p></td></tr></table><p><ins>The</ins><del>If</del> <ins>counters</ins><del>MDCR_EL2.HPMN</del> <ins>affected</ins><del>is</del> <ins>by</ins><del>not</del> <del>0, </del>this field <ins>are:</ins><del>affects the operation of event counters in the range [0 .. (MDCR_EL2.HPMN-1)].</del></p><p><del>This field does not affect the operation of other event counters.</del></p><p><del>If </del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.DP is 1, this field affects </del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del>.</del></p><ul><li><ins>Event counters </ins><a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><ins> for values of n less than MDCR_EL2.HPMN.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_PMUv3_ICNTR</ins></span><ins> is implemented, the instruction counter </ins><a href="AArch64-pmicntr_el0.html"><ins>PMICNTR_EL0</ins></a><ins>.
</ins></li><li><ins>If </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.DP is 1, the cycle counter </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins>.
</ins></li></ul><p><ins>Other event counters are not affected by this field.</ins></p><p><ins>When </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.DP is 0, </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins> is not affected by this field.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-17_17-2"><span class="condition"><br/>When FEAT_PMUv3p1 is implemented:
                        </span></h4><div class="field"><p>Guest Performance Monitors Disable. Controls <ins>PMU</ins><del>event</del> <ins>operation</ins><del>counting</del> <del>by some event counters </del>at <ins>EL2 when</ins><del>EL2.</del> <span class="function"><ins>ExternalSecureNoninvasiveDebugEnabled</ins></span><ins>() is FALSE.</ins></p><table class="valuetable"><tr><th>HPMD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><ins>Counters</ins><del>Event</del> <ins>are</ins><del>counting</del> <ins>not affected by this mechanism.</ins><del>and</del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del> are not affected by this mechanism.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p>If <span class="function">ExternalSecureNoninvasiveDebugEnabled</span>() is FALSE<del>,</del> <ins>then</ins><del>event</del> <ins>all</ins><del>counting</del> <ins>the</ins><del>by</del> <ins>following</ins><del>some</del> <ins>apply:</ins><del>event counters is prohibited at EL2, and if</del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.DP is 1, </del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del> is disabled at EL2.</del></p><ul><li><ins>Affected event counters are prohibited from counting at EL2.
</ins></li><li><ins>If </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.DP is 1, then </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins> is disabled at EL2. Otherwise, </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins> is not affected by this mechanism.
</ins></li></ul></td></tr></table><p>If <span class="function">ExternalSecureNoninvasiveDebugEnabled</span>() is TRUE<del>,</del> <ins>then</ins><del>this</del> <del>field does not affect </del>the event counters and<del> does not affect</del> <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> <ins>are not affected by this field.</ins><del>.</del></p><p>Otherwise<ins>, the counters affected by this field are</ins>:</p><ul><li><del>If </del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.DP is 1, this field affects </del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del>.
</del></li><li><ins>Event</ins><del>If</del> <del>MDCR_EL2.HPMN is not 0, this field affects the operation of event </del>counters<del> in the range [0 .. (MDCR_EL2.HPMN-1)].</del> <a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><ins> for values of n less than MDCR_EL2.HPMN.
</ins></li><li><ins>If</ins><del>This field does not affect the operation of other event counters.</del> <a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.DP is 1, the cycle counter, </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins>.
</ins></li></ul><p><ins>Other event counters are not affected by this field. When </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.DP is 0, </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins> is not affected by this field.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-17_17-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-16_16"><ins>Bit</ins><del>Bits</del> [16<del>:15</del>]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-15_15-1"><ins>EnSPM, bit [15]</ins><span class="condition"><br/><ins>When FEAT_SPMU is implemented:
                        </ins></span></h4><div class="field"><p><ins>Enable access to System PMU registers. When disabled, accesses to System PMU registers generate a trap to EL2.</ins></p><table class="valuetable"><tr><th><ins>EnSPM</ins></th><th><ins>Meaning</ins></th></tr><tr><td class="bitfield"><ins>0b0</ins></td><td><p><ins>Accesses of the specified System PMU registers at EL1 and EL0 are trapped to EL2, unless the instruction generates a higher priority exception.</ins></p></td></tr><tr><td class="bitfield"><ins>0b1</ins></td><td><p><ins>Accesses of the specified System PMU registers are not trapped by this mechanism.</ins></p></td></tr></table><p><ins>In AArch64 state, the instructions affected by this control are: </ins><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-spmaccessr_el1.html"><ins>SPMACCESSR_EL1</ins></a><ins>, </ins><a href="AArch64-spmcfgr_el1.html"><ins>SPMCFGR_EL1</ins></a><ins>, </ins><a href="AArch64-spmcgcrn_el1.html"><ins>SPMCGCR&lt;n>_EL1</ins></a><ins>, </ins><a href="AArch64-spmcntenclr_el0.html"><ins>SPMCNTENCLR_EL0</ins></a><ins>, </ins><a href="AArch64-spmcntenset_el0.html"><ins>SPMCNTENSET_EL0</ins></a><ins>, </ins><a href="AArch64-spmcr_el0.html"><ins>SPMCR_EL0</ins></a><ins>, </ins><a href="AArch64-spmdevaff_el1.html"><ins>SPMDEVAFF_EL1</ins></a><ins>, </ins><a href="AArch64-spmdevarch_el1.html"><ins>SPMDEVARCH_EL1</ins></a><ins>, </ins><a href="AArch64-spmevcntrn_el0.html"><ins>SPMEVCNTR&lt;n>_EL0</ins></a><ins>, </ins><a href="AArch64-spmevfilt2rn_el0.html"><ins>SPMEVFILT2R&lt;n>_EL0</ins></a><ins>, </ins><a href="AArch64-spmevfiltrn_el0.html"><ins>SPMEVFILTR&lt;n>_EL0</ins></a><ins>, </ins><a href="AArch64-spmevtypern_el0.html"><ins>SPMEVTYPER&lt;n>_EL0</ins></a><ins>, </ins><a href="AArch64-spmiidr_el1.html"><ins>SPMIIDR_EL1</ins></a><ins>, </ins><a href="AArch64-spmintenclr_el1.html"><ins>SPMINTENCLR_EL1</ins></a><ins>, </ins><a href="AArch64-spmintenset_el1.html"><ins>SPMINTENSET_EL1</ins></a><ins>, </ins><a href="AArch64-spmovsclr_el0.html"><ins>SPMOVSCLR_EL0</ins></a><ins>, </ins><a href="AArch64-spmovsset_el0.html"><ins>SPMOVSSET_EL0</ins></a><ins>, </ins><a href="AArch64-spmscr_el1.html"><ins>SPMSCR_EL1</ins></a><ins>, and </ins><a href="AArch64-spmselr_el0.html"><ins>SPMSELR_EL0</ins></a><ins>.</ins></p><p><ins>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL2.</ins></p><p><ins>Trapped instructions are reported using EC syndrome value </ins><span class="hexnumber"><ins>0x18</ins></span><ins>.</ins></p><p><ins>The reset behavior of this field is:</ins></p><ul><li><ins>On a Warm reset, 
      this field resets
       to an architecturally </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></li></ul></div><h4 id="fieldset_0-15_15-2"><span class="condition"><br/><ins>Otherwise:
                        </ins></span></h4><div class="field"><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-14_14-1">TPMS, bit [14]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap Performance Monitor Sampling. <ins>Enables</ins><del>If</del> <ins>a</ins><del>EL2</del> <ins>trap</ins><del>is</del> <del>implemented and enabled in the current Security state, controls access </del>to <ins>EL2</ins><del>Statistical</del> <ins>on</ins><del>Profiling</del> <ins>accesses</ins><del>control</del> <ins>of</ins><del>registers</del> <ins>SPE</ins><del>from</del> <ins>registers.</ins><del>EL1.</del></p><table class="valuetable"><tr><th>TPMS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><ins>Accesses</ins><del>Do</del> <ins>of</ins><del>not</del> <ins>the</ins><del>trap</del> <ins>specified</ins><del>Statistical</del> <ins>SPE</ins><del>Profiling</del> <ins>registers</ins><del>controls</del> <ins>are</ins><del>to</del> <ins>not trapped by this mechanism.</ins><del>EL2.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Accesses</ins><del>If</del> <ins>of</ins><del>EL2</del> <ins>the</ins><del>is</del> <ins>specified</ins><del>implemented</del> <ins>SPE</ins><del>and</del> <ins>registers</ins><del>enabled</del> <ins>at</ins><del>in</del> <ins>EL1</ins><del>the</del> <ins>are</ins><del>current</del> <ins>trapped</ins><del>Security</del> <del>state, accesses </del>to <ins>EL2,</ins><del>Statistical</del> <ins>unless</ins><del>Profiling</del> <ins>the</ins><del>control</del> <ins>instruction</ins><del>registers</del> <ins>generates</ins><del>at</del> <del>EL1 generate </del>a <ins>higher</ins><del>Trap</del> <ins>priority</ins><del>exception</del> <ins>exception.</ins><del>to EL2.</del></p></td></tr></table><p><ins>In</ins><del>The</del> <ins>AArch64</ins><del>Statistical</del> <ins>state,</ins><del>Profiling</del> <ins>the</ins><del>control</del> <ins>instructions</ins><del>registers</del> <ins>affected</ins><del>trapped</del> by this control are:</p><ul><li><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>, <a href="AArch64-pmsevfr_el1.html">PMSEVFR_EL1</a>, <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>, <a href="AArch64-pmsicr_el1.html">PMSICR_EL1</a><del>, </del><a href="AArch64-pmsidr_el1.html"><del>PMSIDR_EL1</del></a>, <a href="AArch64-pmsirr_el1.html">PMSIRR_EL1</a>, and <a href="AArch64-pmslatfr_el1.html">PMSLATFR_EL1</a>.
</li><li><span class="instruction"><ins>MRS</ins></span> <ins>accesses</ins><del>If</del> <ins>to</ins><del>FEAT_SPEv1p2 is implemented,</del> <a href="AArch64-pmsidr_el1.html"><ins>PMSIDR_EL1</ins></a><a href="AArch64-pmsnevfr_el1.html"><del>PMSNEVFR_EL1</del></a>.
</li><li><ins>If </ins><span class="xref"><ins>FEAT_SPEv1p2</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-pmsnevfr_el1.html"><ins>PMSNEVFR_EL1</ins></a><ins>.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_SPE_FDS</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-pmsdsfr_el1.html"><ins>PMSDSFR_EL1</ins></a><ins>.
</ins></li></ul><p><ins>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL2.</ins></p><p><ins>Trapped instructions are reported using EC syndrome value </ins><span class="hexnumber"><ins>0x18</ins></span><ins>.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-13_12-1">E2PB, bits [13:12]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>EL2 Profiling Buffer. If EL2 is implemented and enabled in the Profiling Buffer owning Security state, this field controls the owning translation regime. If EL2 is implemented and enabled in the current Security state, this field controls access to Profiling Buffer control registers from EL1.</p><table class="valuetable"><tr><th>E2PB</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>If EL2 is implemented and enabled in the Profiling Buffer owning Security state, the Profiling Buffer uses the EL2 or EL2&amp;0 stage 1 translation regime. Otherwise the Profiling Buffer uses the EL1&amp;0 stage 1 translation regime.</p><p>If EL2 is implemented and enabled in the current Security state, accesses to Profiling Buffer control registers at EL1 generate a Trap exception to EL2.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Profiling Buffer uses the EL1&amp;0 stage 1 translation regime. If EL2 is implemented and enabled in the current Security state, accesses to Profiling Buffer control registers at EL1 generate a Trap exception to EL2.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Profiling Buffer uses the EL1&amp;0 stage 1 translation regime. Accesses to Profiling Buffer control registers at EL1 are not trapped to EL2.</p></td></tr></table><p>All other values are reserved.</p><p>The Profiling Buffer control registers trapped by this control are: <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a>, <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a>, and <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-13_12-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-11_11">TDRA, bit [11]</h4><div class="field"><p>Trap Debug ROM Address register access. Traps System register accesses to the Debug ROM registers to EL2 when EL2 is enabled in the current Security state as follows:</p><ul><li>If EL1 is using AArch64 state, accesses to <a href="AArch64-mdrar_el1.html">MDRAR_EL1</a> are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>.
</li><li>If EL0 or EL1 is using AArch32 state, MRC or MCR accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x05</span> and MRRC or MCRR accesses are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x0C</span>:<ul><li><a href="AArch32-dbgdrar.html">DBGDRAR</a>, <a href="AArch32-dbgdsar.html">DBGDSAR</a>.
</li></ul></li></ul><table class="valuetable"><tr><th>TDRA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL0 and EL1 System register accesses to the Debug ROM registers are trapped to EL2 when EL2 is enabled in the current Security state, unless it is trapped by the following:</p><ul><li><a href="AArch32-dbgdscrext.html">DBGDSCRext</a>.UDCCdis.
</li><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC.
</li></ul></td></tr></table><p>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</p><ul><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDE == 1.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.
</li></ul><div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on debug register accesses through the optional memory-mapped external debug interfaces.</p></div><p>System register accesses to the debug registers might have side-effects. When a System register access is trapped to EL2, no side-effects occur before the exception is taken to EL2.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-10_10-1">TDOSA, bit [10]<span class="condition"><br/>When FEAT_DoubleLock is implemented:
                        </span></h4><div class="field"><p>Trap debug OS-related register access. Traps EL1 System register accesses to the powerdown debug registers to EL2, from both Execution states as follows:</p><ul><li>In AArch64 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>:<ul><li><a href="AArch64-oslar_el1.html">OSLAR_EL1</a>, <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>, <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a>, and <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a>.
</li><li>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li></ul></li><li>In AArch32 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x05</span>:<ul><li><a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, <a href="AArch32-dbgosdlr.html">DBGOSDLR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>.
</li><li>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li></ul></li></ul><table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL1 System register accesses to the powerdown debug registers are trapped to EL2 when EL2 is enabled in the current Security state.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>These registers are not accessible at EL0.</p></div><p>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</p><ul><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDE == 1.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.
</li></ul><p>System register accesses to the debug registers might have side-effects. When a System register access is trapped to EL2, no side-effects occur before the exception is taken to EL2.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-10_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Trap debug OS-related register access. Traps EL1 System register accesses to the powerdown debug registers to EL2, from both Execution states as follows:</p><ul><li><p>In AArch64 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>:</p><ul><li><p><a href="AArch64-oslar_el1.html">OSLAR_EL1</a>, <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>, and <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a>.</p></li><li><p>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.</p></li></ul></li><li><p>In AArch32 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x05</span>:</p><ul><li><p><a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>.</p></li><li><p>Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.</p></li></ul></li></ul><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a> are trapped.</p><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch32-dbgosdlr.html">DBGOSDLR</a> are trapped.</p><table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL1 System register accesses to the powerdown debug registers are trapped to EL2 when EL2 is enabled in the current Security state.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>These registers are not accessible at EL0.</p></div><p>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</p><ul><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDE == 1.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.
</li></ul><div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on debug register accesses through the optional memory-mapped external debug interfaces.</p></div><p>System register accesses to the debug registers might have side-effects. When a System register access is trapped to EL2, no side-effects occur before the exception is taken to EL2.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-9_9">TDA, bit [9]</h4><div class="field"><ul><li><del>In AArch64 state, accesses to the following registers are trapped to EL2 reported using EC syndrome value </del><span class="hexnumber"><del>0x18</del></span><del>:</del><ul><li><a href="AArch64-mdccsr_el0.html"><del>MDCCSR_EL0</del></a><del>, </del><a href="AArch64-mdccint_el1.html"><del>MDCCINT_EL1</del></a><del>, </del><a href="AArch64-osdtrrx_el1.html"><del>OSDTRRX_EL1</del></a><del>, </del><a href="AArch64-mdscr_el1.html"><del>MDSCR_EL1</del></a><del>, </del><a href="AArch64-osdtrtx_el1.html"><del>OSDTRTX_EL1</del></a><del>, </del><a href="AArch64-oseccr_el1.html"><del>OSECCR_EL1</del></a><del>, </del><a href="AArch64-dbgbvrn_el1.html"><del>DBGBVR&lt;n>_EL1</del></a><del>, </del><a href="AArch64-dbgbcrn_el1.html"><del>DBGBCR&lt;n>_EL1</del></a><del>, </del><a href="AArch64-dbgwvrn_el1.html"><del>DBGWVR&lt;n>_EL1</del></a><del>, </del><a href="AArch64-dbgwcrn_el1.html"><del>DBGWCR&lt;n>_El1</del></a><del>, </del><a href="AArch64-dbgclaimset_el1.html"><del>DBGCLAIMSET_EL1</del></a><del>, </del><a href="AArch64-dbgclaimclr_el1.html"><del>DBGCLAIMCLR_EL1</del></a><del>, </del><a href="AArch64-dbgauthstatus_el1.html"><del>DBGAUTHSTATUS_EL1</del></a><del>.
</del></li><li><del>When not in Debug state, </del><a href="AArch64-dbgdtr_el0.html"><del>DBGDTR_EL0</del></a><del>, </del><a href="AArch64-dbgdtrrx_el0.html"><del>DBGDTRRX_EL0</del></a><del>, </del><a href="AArch64-dbgdtrtx_el0.html"><del>DBGDTRTX_EL0</del></a><del>.
</del></li></ul></li><li><del>In AArch32 state, MRC or MCR accesses to the following registers are trapped to EL2, reported using EC syndrome value </del><span class="hexnumber"><del>0x05</del></span><del>.</del><ul><li><a href="AArch32-dbgdidr.html"><del>DBGDIDR</del></a><del>, </del><a href="AArch32-dbgdscrint.html"><del>DBGDSCRint</del></a><del>, </del><a href="AArch32-dbgdccint.html"><del>DBGDCCINT</del></a><del>, </del><a href="AArch32-dbgwfar.html"><del>DBGWFAR</del></a><del>, </del><a href="AArch32-dbgvcr.html"><del>DBGVCR</del></a><del>, </del><a href="AArch32-dbgdscrext.html"><del>DBGDSCRext</del></a><del>, </del><a href="AArch32-dbgdtrtxext.html"><del>DBGDTRTXext</del></a><del>, </del><a href="AArch32-dbgdtrrxext.html"><del>DBGDTRRXext</del></a><del>, </del><a href="AArch32-dbgbvrn.html"><del>DBGBVR&lt;n></del></a><del>, </del><a href="AArch32-dbgbcrn.html"><del>DBGBCR&lt;n></del></a><del>, </del><a href="AArch32-dbgbxvrn.html"><del>DBGBXVR&lt;n></del></a><del>, </del><a href="AArch32-dbgwcrn.html"><del>DBGWCR&lt;n></del></a><del>, </del><a href="AArch32-dbgwvrn.html"><del>DBGWVR&lt;n></del></a><del>, </del><a href="AArch32-dbgclaimset.html"><del>DBGCLAIMSET</del></a><del>, </del><a href="AArch32-dbgclaimclr.html"><del>DBGCLAIMCLR</del></a><del>, </del><a href="AArch32-dbgauthstatus.html"><del>DBGAUTHSTATUS</del></a><del>, </del><a href="AArch32-dbgdevid.html"><del>DBGDEVID</del></a><del>, </del><a href="AArch32-dbgdevid1.html"><del>DBGDEVID1</del></a><del>, </del><a href="AArch32-dbgdevid2.html"><del>DBGDEVID2</del></a><del>, </del><a href="AArch32-dbgoseccr.html"><del>DBGOSECCR</del></a><del>.
</del></li><li><del>When not in Debug state, </del><a href="AArch32-dbgdtrrxint.html"><del>DBGDTRRXint</del></a><del> and </del><a href="AArch32-dbgdtrtxint.html"><del>DBGDTRTXint</del></a><del>.
</del></li></ul></li><li><del>In AArch32 state, STC accesses to </del><a href="AArch32-dbgdtrrxint.html"><del>DBGDTRRXint</del></a><del> and LDC accesses to </del><a href="AArch32-dbgdtrtxint.html"><del>DBGDTRTXint</del></a><del> are trapped to EL2, reported using EC syndrome value </del><span class="hexnumber"><del>0x06</del></span><del>.
</del></li></ul><p>Trap <del>Debug Access. Traps EL0 and EL1 System register </del>accesses <ins>of</ins><del>to</del> debug System <ins>registers.</ins><del>registers</del> <ins>Enables</ins><del>that</del> <ins>a</ins><del>are</del> <ins>trap</ins><del>not</del> <ins>to</ins><del>trapped</del> <ins>EL2</ins><del>by</del> <ins>on</ins><del>MDCR_EL2.TDRA</del> <ins>accesses</ins><del>or</del> <ins>of</ins><del>MDCR_EL2.TDOSA,</del> <ins>debug</ins><del>as</del> <ins>System registers.</ins><del>follows:</del></p><table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><ins>Accesses</ins><del>This</del> <ins>of</ins><del>control</del> <ins>the</ins><del>does</del> <ins>specified</ins><del>not</del> <ins>debug</ins><del>cause</del> <ins>System</ins><del>any</del> <ins>registers</ins><del>instructions</del> <ins>are</ins><del>to</del> <ins>not</ins><del>be</del> <ins>trapped by this mechanism.</ins><del>trapped.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Accesses</ins><del>EL0</del> <ins>of</ins><del>or</del> <ins>the</ins><del>EL1</del> <ins>specified</ins><del>System</del> <ins>debug</ins><del>register</del> <ins>System</ins><del>accesses</del> <ins>registers</ins><del>to</del> <ins>at</ins><del>the</del> <ins>EL1</ins><del>debug</del> <ins>and</ins><del>registers</del> <ins>EL0 </ins>are trapped <del>from both Execution states </del>to EL2<del> when EL2 is enabled in the current Security state</del>, unless the <ins>instruction</ins><del>access</del> generates a higher priority exception.</p></td></tr></table><p><ins>In</ins><del>Traps</del> <ins>AArch64</ins><del>of</del> <ins>state,</ins><del>AArch32</del> <ins>the</ins><del>accesses</del> <ins>instructions affected by this control are:</ins><del>to</del><a href="AArch32-dbgdtrrxint.html"><del>DBGDTRRXint</del></a><del> and </del><a href="AArch32-dbgdtrtxint.html"><del>DBGDTRTXint</del></a><del> are ignored in Debug state.</del></p><p><del>Traps of AArch64 accesses to </del><a href="AArch64-dbgdtr_el0.html"><del>DBGDTR_EL0</del></a><del>, </del><a href="AArch64-dbgdtrrx_el0.html"><del>DBGDTRRX_EL0</del></a><del>, and </del><a href="AArch64-dbgdtrtx_el0.html"><del>DBGDTRTX_EL0</del></a><del> are ignored in Debug state.</del></p><p><del>This field is treated as being 1 for all purposes other than a direct read when one or more of the following are true:</del></p><ul><li><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-dbgauthstatus_el1.html"><ins>DBGAUTHSTATUS_EL1</ins></a><ins>, </ins><a href="AArch64-dbgbcrn_el1.html"><ins>DBGBCR&lt;n>_EL1</ins></a><ins>, </ins><a href="AArch64-dbgbvrn_el1.html"><ins>DBGBVR&lt;n>_EL1</ins></a><ins>, </ins><a href="AArch64-dbgclaimclr_el1.html"><ins>DBGCLAIMCLR_EL1</ins></a><ins>, </ins><a href="AArch64-dbgclaimset_el1.html"><ins>DBGCLAIMSET_EL1</ins></a><ins>, </ins><a href="AArch64-dbgwcrn_el1.html"><ins>DBGWCR&lt;n>_EL1</ins></a><ins>, </ins><a href="AArch64-dbgwvrn_el1.html"><ins>DBGWVR&lt;n>_EL1</ins></a><ins>, </ins><a href="AArch64-mdccint_el1.html"><ins>MDCCINT_EL1</ins></a><ins>, </ins><a href="AArch64-mdccsr_el0.html"><ins>MDCCSR_EL0</ins></a><ins>, </ins><a href="AArch64-mdscr_el1.html"><ins>MDSCR_EL1</ins></a><ins>, </ins><a href="AArch64-osdtrrx_el1.html"><ins>OSDTRRX_EL1</ins></a><ins>, </ins><a href="AArch64-osdtrtx_el1.html"><ins>OSDTRTX_EL1</ins></a><ins>, and </ins><a href="AArch64-oseccr_el1.html"><ins>OSECCR_EL1</ins></a><ins>.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_Debugv8p9</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-mdselr_el1.html"><ins>MDSELR_EL1</ins></a><ins>.
</ins></li><li><ins>In Non-debug state, </ins><span class="instruction"><ins>MRS</ins></span><ins> accesses to </ins><a href="AArch64-dbgdtrrx_el0.html"><ins>DBGDTRRX_EL0</ins></a><ins> and </ins><a href="AArch64-dbgdtr_el0.html"><ins>DBGDTR_EL0</ins></a><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-dbgdtrtx_el0.html"><ins>DBGDTRTX_EL0</ins></a><ins> and </ins><a href="AArch64-dbgdtr_el0.html"><ins>DBGDTR_EL0</ins></a><ins>.
</ins></li></ul><p><ins>In AArch32 state, the instructions affected by this control are:</ins></p><ul><li><p><span class="instruction"><ins>MRC</ins></span><ins> and </ins><span class="instruction"><ins>MCR</ins></span><ins> accesses to </ins><a href="AArch32-dbgauthstatus.html"><ins>DBGAUTHSTATUS</ins></a><ins>, </ins><a href="AArch32-dbgbcrn.html"><ins>DBGBCR&lt;n></ins></a><ins>, </ins><a href="AArch32-dbgbvrn.html"><ins>DBGBVR&lt;n></ins></a><ins>, </ins><a href="AArch32-dbgbxvrn.html"><ins>DBGBXVR&lt;n></ins></a><ins>, </ins><a href="AArch32-dbgclaimclr.html"><ins>DBGCLAIMCLR</ins></a><ins>, </ins><a href="AArch32-dbgclaimset.html"><ins>DBGCLAIMSET</ins></a><ins>, </ins><a href="AArch32-dbgdccint.html"><ins>DBGDCCINT</ins></a><ins>, </ins><a href="AArch32-dbgdevid.html"><ins>DBGDEVID</ins></a><ins>, </ins><a href="AArch32-dbgdevid1.html"><ins>DBGDEVID1</ins></a><ins>, </ins><a href="AArch32-dbgdevid2.html"><ins>DBGDEVID2</ins></a><ins>, </ins><a href="AArch32-dbgdidr.html"><ins>DBGDIDR</ins></a><ins>, </ins><a href="AArch32-dbgdscrext.html"><ins>DBGDSCRext</ins></a><ins>, </ins><a href="AArch32-dbgdscrint.html"><ins>DBGDSCRint</ins></a><ins>, </ins><a href="AArch32-dbgdtrrxext.html"><ins>DBGDTRRXext</ins></a><ins>, </ins><a href="AArch32-dbgdtrtxext.html"><ins>DBGDTRTXext</ins></a><ins>, </ins><a href="AArch32-dbgoseccr.html"><ins>DBGOSECCR</ins></a><ins>, </ins><a href="AArch32-dbgvcr.html"><ins>DBGVCR</ins></a><ins>, </ins><a href="AArch32-dbgwcrn.html"><ins>DBGWCR&lt;n></ins></a><ins>, </ins><a href="AArch32-dbgwfar.html"><ins>DBGWFAR</ins></a><ins>, and </ins><a href="AArch32-dbgwvrn.html"><ins>DBGWVR&lt;n></ins></a><ins>.</ins></p></li><li><p><span class="instruction"><ins>STC</ins></span><ins> accesses to </ins><a href="AArch32-dbgdtrrxint.html"><ins>DBGDTRRXint</ins></a><ins> and </ins><span class="instruction"><ins>LDC</ins></span><ins> accesses to </ins><a href="AArch32-dbgdtrtxint.html"><ins>DBGDTRTXint</ins></a><ins>.</ins></p></li><li><p><ins>In Non-debug state, </ins><span class="instruction"><ins>MRC</ins></span><ins> accesses to </ins><a href="AArch32-dbgdtrrxint.html"><ins>DBGDTRRXint</ins></a><ins> and </ins><span class="instruction"><ins>MCR</ins></span><ins> accesses to </ins><a href="AArch32-dbgdtrtxint.html"><ins>DBGDTRTXint</ins></a><ins>.</ins></p></li></ul><p><ins>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL2.</ins></p><p><ins>Trapped AArch64 instructions are reported using EC syndrome value </ins><span class="hexnumber"><ins>0x18</ins></span><ins>.</ins></p><p><ins>Trapped AArch32 instructions are reported using EC syndrome value </ins><span class="hexnumber"><ins>0x05</ins></span><ins> for </ins><span class="instruction"><ins>MRC</ins></span><ins> and </ins><span class="instruction"><ins>MCR</ins></span><ins> accesses, and </ins><span class="hexnumber"><ins>0x06</ins></span><ins> for </ins><span class="instruction"><ins>LDC</ins></span><ins> and </ins><span class="instruction"><ins>STC</ins></span><ins> accesses.</ins></p><p><ins>The following instructions are not trapped in Debug state:</ins></p><ul><li><ins>AArch64 </ins><span class="instruction"><ins>MRS</ins></span><ins> accesses to </ins><a href="AArch64-dbgdtrrx_el0.html"><ins>DBGDTRRX_EL0</ins></a><ins> and </ins><a href="AArch64-dbgdtr_el0.html"><ins>DBGDTR_EL0</ins></a><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-dbgdtrtx_el0.html"><ins>DBGDTRTX_EL0</ins></a><ins> and </ins><a href="AArch64-dbgdtr_el0.html"><ins>DBGDTR_EL0</ins></a><ins>.
</ins></li><li><ins>AArch32 </ins><span class="instruction"><ins>MRC</ins></span><ins> accesses to </ins><a href="AArch32-dbgdtrrxint.html"><ins>DBGDTRRXint</ins></a><ins> and </ins><span class="instruction"><ins>MCR</ins></span><ins> accesses to </ins><a href="AArch32-dbgdtrtxint.html"><ins>DBGDTRTXint</ins></a><ins>.
</ins></li></ul><p><ins>If 16 or fewer breakpoints and 16 or fewer watchpoints are implemented, and </ins><a href="AArch64-mdselr_el1.html"><ins>MDSELR_EL1</ins></a><ins> is implemented as RAZ/WI, then it is </ins><span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> whether AArch64 accesses to </ins><a href="AArch64-mdselr_el1.html"><ins>MDSELR_EL1</ins></a><ins> are trapped to EL2 when MDCR_EL2.TDA is 1.</ins></p><p><ins>This field is ignored by the PE and treated as one when any of the following are true:</ins></p><ul><li><a href="AArch64-mdcr_el2.html"><del>MDCR_EL2</del></a><ins>MDCR_EL2.TDE</ins><del>.TDE</del> == <ins>1.</ins><del>1</del>
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-8_8">TDE, bit [8]</h4><div class="field"><p>Trap Debug Exceptions. Controls routing of Debug exceptions, and defines the debug target Exception level, EL<sub>D</sub>.</p><table class="valuetable"><tr><th>TDE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The debug target Exception level is EL1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is enabled for the current Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS, the debug target Exception level is EL2, otherwise the debug target Exception level is EL1.</p><p>The MDCR_EL2.{TDRA, TDOSA, TDA} fields are treated as being 1 for all purposes other than returning the result of a direct read of the register.</p></td></tr></table><p>For more information, see <span class="xref">'Routing debug exceptions'</span>.</p><p>This field is treated as being 1 for all purposes other than a direct read when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_7-1">HPME, bit [7]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p><ins>Hyp</ins><del>[MDCR_EL2.HPMN..(N-1)]</del> <ins>Enable.</ins><del>event counters enable.</del></p><table class="valuetable"><tr><th>HPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><ins>Affected</ins><del>Event</del> counters <ins>are</ins><del>in</del> <ins>disabled</ins><del>the</del> <ins>and</ins><del>range</del> <ins>do not count.</ins><del>[MDCR_EL2.HPMN..(</del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.N-1)] are disabled.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Affected</ins><del>Event</del> counters <ins>are</ins><del>in</del> <ins>enabled</ins><del>the</del> <ins>by</ins><del>range [MDCR_EL2.HPMN..(</del> <a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.N-1)] are enabled by </del><a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>.</p></td></tr></table><p><ins>The</ins><del>If</del> <ins>counters</ins><del>MDCR_EL2.HPMN</del> <ins>affected</ins><del>is</del> <ins>by</ins><del>less</del> <ins>this field are event counters</ins><del>than</del> <a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a> <ins>for</ins><del>.N,</del> <ins>values</ins><del>this</del> <ins>of</ins><del>field</del> <ins>n</ins><del>affects</del> <ins>greater</ins><del>the</del> <ins>than</ins><del>operation</del> <ins>or</ins><del>of</del> <ins>equal</ins><del>event</del> <ins>to</ins><del>counters</del> <ins>MDCR_EL2.HPMN</ins><del>in</del> <ins>and</ins><del>the</del> <ins>less</ins><del>range</del> <ins>than</ins><del>[MDCR_EL2.HPMN..(</del> <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.<ins>N. This applies even when EL2 is disabled in the current Security state.</ins><del>N-1)].</del></p><p><ins>Other</ins><del>This</del> <del>field does not affect the operation of other </del>event <ins>counters,</ins><del>counters.</del> <a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins>, and, if </ins><span class="xref"><ins>FEAT_PMUv3_ICNTR</ins></span><ins> is implemented, </ins><a href="AArch64-pmicntr_el0.html"><ins>PMICNTR_EL0</ins></a><ins> are not affected by this field.</ins></p><p><ins>If</ins><del>The</del> <ins>MDCR_EL2.HPMN</ins><del>operation</del> <del>of this field applies even when EL2 </del>is <ins>equal</ins><del>disabled</del> <ins>to</ins><del>in the current Security state.</del> <a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.N, then this field has no effect.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_7-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-6_6-1">TPM, bit [6]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><ul><li><p><del>In AArch64 state, accesses to the following registers are trapped to EL2, reported using EC syndrome value </del><span class="hexnumber"><del>0x18</del></span><del>:</del></p><ul><li><p><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>, </del><a href="AArch64-pmcntenset_el0.html"><del>PMCNTENSET_EL0</del></a><del>, </del><a href="AArch64-pmcntenclr_el0.html"><del>PMCNTENCLR_EL0</del></a><del>, </del><a href="AArch64-pmovsclr_el0.html"><del>PMOVSCLR_EL0</del></a><del>, </del><a href="AArch64-pmswinc_el0.html"><del>PMSWINC_EL0</del></a><del>, </del><a href="AArch64-pmselr_el0.html"><del>PMSELR_EL0</del></a><del>, </del><a href="AArch64-pmceid0_el0.html"><del>PMCEID0_EL0</del></a><del>, </del><a href="AArch64-pmceid1_el0.html"><del>PMCEID1_EL0</del></a><del>, </del><a href="AArch64-pmccntr_el0.html"><del>PMCCNTR_EL0</del></a><del>, </del><a href="AArch64-pmxevtyper_el0.html"><del>PMXEVTYPER_EL0</del></a><del>, </del><a href="AArch64-pmxevcntr_el0.html"><del>PMXEVCNTR_EL0</del></a><del>, </del><a href="AArch64-pmuserenr_el0.html"><del>PMUSERENR_EL0</del></a><del>, </del><a href="AArch64-pmintenset_el1.html"><del>PMINTENSET_EL1</del></a><del>, </del><a href="AArch64-pmintenclr_el1.html"><del>PMINTENCLR_EL1</del></a><del>, </del><a href="AArch64-pmovsset_el0.html"><del>PMOVSSET_EL0</del></a><del>, </del><a href="AArch64-pmevcntrn_el0.html"><del>PMEVCNTR&lt;n>_EL0</del></a><del>, </del><a href="AArch64-pmevtypern_el0.html"><del>PMEVTYPER&lt;n>_EL0</del></a><del>, </del><a href="AArch64-pmccfiltr_el0.html"><del>PMCCFILTR_EL0</del></a><del>.</del></p></li><li><p><del>If </del><span class="xref"><del>FEAT_PMUv3p4</del></span><del> is implemented, </del><a href="AArch64-pmmir_el1.html"><del>PMMIR_EL1</del></a></p></li></ul></li><li><p><del>In AArch32 state, MRC or MCR accesses to the following registers are trapped to EL2 and reported using EC syndrome value </del><span class="hexnumber"><del>0x03</del></span><del>, MRRC or MCRR accesses are trapped to EL2 and reported using EC syndrome value </del><span class="hexnumber"><del>0x04</del></span><del>:</del></p><ul><li><p><a href="AArch32-pmcr.html"><del>PMCR</del></a><del>, </del><a href="AArch32-pmcntenset.html"><del>PMCNTENSET</del></a><del>, </del><a href="AArch32-pmcntenclr.html"><del>PMCNTENCLR</del></a><del>, </del><a href="AArch32-pmovsr.html"><del>PMOVSR</del></a><del>, </del><a href="AArch32-pmswinc.html"><del>PMSWINC</del></a><del>, </del><a href="AArch32-pmselr.html"><del>PMSELR</del></a><del>, </del><a href="AArch32-pmceid0.html"><del>PMCEID0</del></a><del>, </del><a href="AArch32-pmceid1.html"><del>PMCEID1</del></a><del>, </del><a href="AArch32-pmccntr.html"><del>PMCCNTR</del></a><del>, </del><a href="AArch32-pmxevtyper.html"><del>PMXEVTYPER</del></a><del>, </del><a href="AArch32-pmxevcntr.html"><del>PMXEVCNTR</del></a><del>, </del><a href="AArch32-pmuserenr.html"><del>PMUSERENR</del></a><del>, </del><a href="AArch32-pmintenset.html"><del>PMINTENSET</del></a><del>, </del><a href="AArch32-pmintenclr.html"><del>PMINTENCLR</del></a><del>, </del><a href="AArch32-pmovsset.html"><del>PMOVSSET</del></a><del>, </del><a href="AArch32-pmevcntrn.html"><del>PMEVCNTR&lt;n></del></a><del>, </del><a href="AArch32-pmevtypern.html"><del>PMEVTYPER&lt;n></del></a><del>, </del><a href="AArch32-pmccfiltr.html"><del>PMCCFILTR</del></a><del>.</del></p></li><li><p><del>If </del><span class="xref"><del>FEAT_PMUv3p1</del></span><del> is implemented, </del><a href="AArch32-pmceid2.html"><del>PMCEID2</del></a><del>, and </del><a href="AArch32-pmceid3.html"><del>PMCEID3</del></a><del>.</del></p></li><li><p><del>If </del><span class="xref"><del>FEAT_PMUv3p4</del></span><del> is implemented, </del><a href="AArch32-pmmir.html"><del>PMMIR</del></a><del>.</del></p></li></ul></li></ul><p>Trap <ins>accesses</ins><del>Performance</del> <ins>of</ins><del>Monitors</del> <ins>PMU</ins><del>accesses.</del> <ins>registers.</ins><del>Traps</del> <ins>Enables</ins><del>EL0</del> <ins>a</ins><del>and</del> <ins>trap</ins><del>EL1</del> <del>accesses </del>to <del>all Performance Monitor registers to </del>EL2 <ins>on</ins><del>when</del> <ins>accesses</ins><del>EL2</del> <ins>of</ins><del>is</del> <ins>PMU</ins><del>enabled</del> <ins>registers.</ins><del>in the current Security state, from both Execution states, as follows:</del></p><table class="valuetable"><tr><th>TPM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><ins>Accesses</ins><del>This</del> <ins>of</ins><del>control</del> <ins>the</ins><del>does</del> <ins>specified</ins><del>not</del> <ins>PMU</ins><del>cause</del> <ins>registers</ins><del>any</del> <ins>are</ins><del>instructions</del> <ins>not</ins><del>to</del> <ins>trapped</ins><del>be</del> <ins>by this mechanism.</ins><del>trapped.</del></p></td></tr><tr><td class="bitfield">0b1</td><td><p><ins>Accesses</ins><del>EL0</del> <ins>of</ins><del>and</del> <ins>the</ins><del>EL1</del> <ins>specified</ins><del>accesses</del> <ins>PMU</ins><del>to</del> <ins>registers</ins><del>all</del> <ins>at</ins><del>Performance</del> <ins>EL1</ins><del>Monitor</del> <ins>and</ins><del>registers</del> <ins>EL0 </ins>are trapped to EL2<ins>,</ins> <ins>unless</ins><del>when</del> <ins>the</ins><del>EL2</del> <ins>instruction</ins><del>is</del> <ins>generates</ins><del>enabled</del> <ins>a</ins><del>in</del> <ins>higher</ins><del>the</del> <ins>priority</ins><del>current</del> <ins>exception.</ins><del>Security state.</del></p></td></tr></table><div class="note"><span class="note-header"><del class="nocount">Note</del></span><p><del>EL2 does not provide traps on Performance Monitor register accesses through the optional memory-mapped external debug interface.</del></p></div><p><ins>In AArch64 state, the instructions affected by this control are:</ins></p><ul><li><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-pmccfiltr_el0.html"><ins>PMCCFILTR_EL0</ins></a><ins>, </ins><a href="AArch64-pmccntr_el0.html"><ins>PMCCNTR_EL0</ins></a><ins>, </ins><a href="AArch64-pmcntenclr_el0.html"><ins>PMCNTENCLR_EL0</ins></a><ins>, </ins><a href="AArch64-pmcntenset_el0.html"><ins>PMCNTENSET_EL0</ins></a><ins>, </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>, </ins><a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><ins>, </ins><a href="AArch64-pmevtypern_el0.html"><ins>PMEVTYPER&lt;n>_EL0</ins></a><ins>, </ins><a href="AArch64-pmintenclr_el1.html"><ins>PMINTENCLR_EL1</ins></a><ins>, </ins><a href="AArch64-pmintenset_el1.html"><ins>PMINTENSET_EL1</ins></a><ins>, </ins><a href="AArch64-pmovsclr_el0.html"><ins>PMOVSCLR_EL0</ins></a><ins>, </ins><a href="AArch64-pmovsset_el0.html"><ins>PMOVSSET_EL0</ins></a><ins>, </ins><a href="AArch64-pmselr_el0.html"><ins>PMSELR_EL0</ins></a><ins>, </ins><a href="AArch64-pmswinc_el0.html"><ins>PMSWINC_EL0</ins></a><ins>, </ins><a href="AArch64-pmuserenr_el0.html"><ins>PMUSERENR_EL0</ins></a><ins>, </ins><a href="AArch64-pmxevcntr_el0.html"><ins>PMXEVCNTR_EL0</ins></a><ins>, and </ins><a href="AArch64-pmxevtyper_el0.html"><ins>PMXEVTYPER_EL0</ins></a><ins>.
</ins></li><li><span class="instruction"><ins>MRS</ins></span><ins> accesses to </ins><a href="AArch64-pmceid0_el0.html"><ins>PMCEID0_EL0</ins></a><ins> and </ins><a href="AArch64-pmceid1_el0.html"><ins>PMCEID1_EL0</ins></a><ins>.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_PMUv3p4</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> accesses to </ins><a href="AArch64-pmmir_el1.html"><ins>PMMIR_EL1</ins></a><ins>.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_PMUv3p9</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-pmzr_el0.html"><ins>PMZR_EL0</ins></a><ins>.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_PMUv3_ICNTR</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> accesses to </ins><a href="AArch64-pmicfiltr_el0.html"><ins>PMICFILTR_EL0</ins></a><ins> and </ins><a href="AArch64-pmicntr_el0.html"><ins>PMICNTR_EL0</ins></a><ins>.
</ins></li><li><ins>If FEAT_EBEP is implemented or </ins><span class="xref"><ins>FEAT_PMUv3_SS</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-pmecr_el1.html"><ins>PMECR_EL1</ins></a><ins>.
</ins></li><li><ins>If </ins><span class="xref"><ins>FEAT_SEBEP</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRS</ins></span><ins> and </ins><span class="instruction"><ins>MSR</ins></span><ins> accesses to </ins><a href="AArch64-pmiar_el1.html"><ins>PMIAR_EL1</ins></a><ins>.
</ins></li></ul><p><ins>In AArch32 state, the instructions affected by this control are:</ins></p><ul><li><p><span class="instruction"><ins>MRC</ins></span><ins> and </ins><span class="instruction"><ins>MCR</ins></span><ins> accesses to </ins><a href="AArch32-pmccfiltr.html"><ins>PMCCFILTR</ins></a><ins>, </ins><a href="AArch32-pmccntr.html"><ins>PMCCNTR</ins></a><ins>, </ins><a href="AArch32-pmcntenclr.html"><ins>PMCNTENCLR</ins></a><ins>, </ins><a href="AArch32-pmcntenset.html"><ins>PMCNTENSET</ins></a><ins>, </ins><a href="AArch32-pmcr.html"><ins>PMCR</ins></a><ins>, </ins><a href="AArch32-pmevcntrn.html"><ins>PMEVCNTR&lt;n></ins></a><ins>, </ins><a href="AArch32-pmevtypern.html"><ins>PMEVTYPER&lt;n></ins></a><ins>, </ins><a href="AArch32-pmintenclr.html"><ins>PMINTENCLR</ins></a><ins>, </ins><a href="AArch32-pmintenset.html"><ins>PMINTENSET</ins></a><ins>, </ins><a href="AArch32-pmovsr.html"><ins>PMOVSR</ins></a><ins>, </ins><a href="AArch32-pmovsset.html"><ins>PMOVSSET</ins></a><ins>, </ins><a href="AArch32-pmselr.html"><ins>PMSELR</ins></a><ins>, </ins><a href="AArch32-pmswinc.html"><ins>PMSWINC</ins></a><ins>, </ins><a href="AArch32-pmuserenr.html"><ins>PMUSERENR</ins></a><ins>, </ins><a href="AArch32-pmxevcntr.html"><ins>PMXEVCNTR</ins></a><ins>, and </ins><a href="AArch32-pmxevtyper.html"><ins>PMXEVTYPER</ins></a><ins>.</ins></p></li><li><p><span class="instruction"><ins>MRC</ins></span><ins> accesses to </ins><a href="AArch32-pmceid0.html"><ins>PMCEID0</ins></a><ins> and </ins><a href="AArch32-pmceid1.html"><ins>PMCEID1</ins></a><ins>.</ins></p></li><li><p><span class="instruction"><ins>MRRC</ins></span><ins> and </ins><span class="instruction"><ins>MCRR</ins></span><ins> accesses to </ins><a href="AArch32-pmccntr.html"><ins>PMCCNTR</ins></a><ins>.</ins></p></li><li><p><ins>If </ins><span class="xref"><ins>FEAT_PMUv3p1</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRC</ins></span><ins> accesses to </ins><a href="AArch32-pmceid2.html"><ins>PMCEID2</ins></a><ins> and </ins><a href="AArch32-pmceid3.html"><ins>PMCEID3</ins></a><ins>.</ins></p></li><li><p><ins>If </ins><span class="xref"><ins>FEAT_PMUv3p4</ins></span><ins> is implemented, </ins><span class="instruction"><ins>MRC</ins></span><ins> accesses to </ins><a href="AArch32-pmmir.html"><ins>PMMIR</ins></a><ins>.</ins></p></li></ul><p><ins>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL2.</ins></p><p><ins>Trapped AArch64 instructions are reported using EC syndrome value </ins><span class="hexnumber"><ins>0x18</ins></span><ins>.</ins></p><p><ins>Trapped AArch32 instructions are reported using EC syndrome value </ins><span class="hexnumber"><ins>0x03</ins></span><ins> for </ins><span class="instruction"><ins>MRC</ins></span><ins> and </ins><span class="instruction"><ins>MCR</ins></span><ins> accesses, and </ins><span class="hexnumber"><ins>0x04</ins></span><ins> for </ins><span class="instruction"><ins>MRRC</ins></span><ins> and </ins><span class="instruction"><ins>MCRR</ins></span><ins> accesses.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-5_5-1">TPMCR, bit [5]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> or <a href="AArch32-pmcr.html">PMCR</a> accesses. Traps EL0 and EL1 accesses to EL2, when EL2 is enabled in the current Security state, as follows:</p><ul><li><p>In AArch64 state, accesses to <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p></li><li><p>In AArch32 state, accesses to <a href="AArch32-pmcr.html">PMCR</a> are trapped to EL2, reported using EC syndrome value <span class="hexnumber">0x03</span>.</p></li></ul><table class="valuetable"><tr><th>TPMCR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause any instructions to be trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>EL0 and EL1 accesses to the specified registers are trapped to EL2 when EL2 is enabled in the current Security state, unless it is trapped by the following:</p><ul><li><a href="AArch32-pmuserenr.html">PMUSERENR</a>.EN.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.EN.
</li></ul></td></tr></table><div class="note"><span class="note-header">Note</span><p>EL2 does not provide traps on Performance Monitor register accesses through the optional memory-mapped external debug interface.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-5_5-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-4_0-1">HPMN, bits [4:0]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Defines the number of event counters <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a> and, if <span class="xref">FEAT_PMUv3_SS</span> is implemented, snapshot registers <a href="AArch64-pmevcntsvrn_el1.html">PMEVCNTSVR&lt;n>_EL1</a><ins>, </ins>that are accessible from <del>EL3, EL2, </del>EL1<del>,</del> and from EL0 if permitted.</p><p><ins>MDCR_EL2.HPMN</ins><del>Defines</del> <ins>divides </ins>the <del>number of </del>event counters<ins> into a first range and a second range.</ins><a href="AArch64-pmevcntrn_el0.html"><del>PMEVCNTR&lt;n>_EL0</del></a><del> that are accessible from EL3, EL2, EL1, and from EL0 if permitted.</del></p><p>If <ins>MDCR_EL2.HPMN</ins><del>HPMN</del> is not 0 and is less than <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N, <ins>then</ins><del>HPMN</del> <del>divides the </del>event counters <ins>[0..(MDCR_EL2.HPMN-1)]</ins><del>into</del> <ins>are</ins><del>a</del> <ins>in the </ins>first range<ins>,</ins> <del>[0..(HPMN-1)], </del>and <ins>the</ins><del>a</del> <ins>remaining</ins><del>second</del> <ins>event</ins><del>range</del> <ins>counters </ins>[<ins>MDCR_EL2.HPMN..</ins><del>HPMN..</del>(<a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N-1<ins>)] are in the second range.</ins><del>)].</del></p><p>If <span class="xref">FEAT_HPMN0</span> is implemented and <ins>MDCR_EL2.HPMN</ins><del>this</del> <del>field </del>is 0,<ins> then</ins> all event counters are in the second range and none are in the first range.</p><p>If <ins>MDCR_EL2.HPMN</ins><del>HPMN</del> is equal to <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N, <ins>then </ins>all event counters are in the first range and none are in the second range.</p><p>For an event counter<del> &lt;n> in the first range:</del> <a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><ins> in the first range:</ins></p><ul><li>The counter is accessible from EL1, EL2, and EL3.
</li><li>The counter is accessible from EL0 if permitted by <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a> <ins>and</ins><del>or</del> <a href="AArch64-pmuacr_el1.html"><ins>PMUACR_EL1</ins></a><ins>, or by </ins><a href="AArch32-pmuserenr.html">PMUSERENR</a>.
</li><li>If <span class="xref">FEAT_PMUv3p5</span> is implemented, <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.LP or <a href="AArch32-pmcr.html">PMCR</a>.LP determines whether the counter overflow flag is set on unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>[31:0] or <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>[63:0].
</li><li><a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.E and <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>[n] enable the operation of <ins>the </ins>event <ins>counter.</ins><del>counter n.</del>
</li></ul><p>For an event counter<del> &lt;n> in the second range:</del> <a href="AArch64-pmevcntrn_el0.html"><ins>PMEVCNTR&lt;n>_EL0</ins></a><ins> in the second range:</ins></p><ul><li>The counter is accessible from EL2 and EL3.
</li><li>If EL2 is disabled in the current Security state, the event counter is also accessible from EL1, and from EL0 if permitted by <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a> <ins>and</ins><del>.</del> <a href="AArch64-pmuacr_el1.html"><ins>PMUACR_EL1</ins></a><ins>, or by </ins><a href="AArch32-pmuserenr.html"><ins>PMUSERENR</ins></a><ins>.
</ins></li><li>If <span class="xref">FEAT_PMUv3p5</span> is implemented, MDCR_EL2.HLP determines whether the counter overflow flag is set on unsigned overflow of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>[31:0] or <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>[63:0].
</li><li>MDCR_EL2.HPME and <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>[n] enable the operation of <ins>the </ins>event <ins>counter.</ins><del>counter n.</del>
</li></ul><p><ins>If </ins><span class="xref"><ins>FEAT_PMUv3_SS</ins></span><ins> is implemented:</ins></p><p><del>If HPMN is larger than </del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.N, or if </del><span class="xref"><del>FEAT_HPMN0</del></span><del> is not implemented and HPMN is 0, the following </del><span class="arm-defined-word"><del>CONSTRAINED UNPREDICTABLE</del></span><del> behaviors apply:</del></p><ul><li><p><ins>For an event counter snapshot register </ins><a href="AArch64-pmevcntsvrn_el1.html"><ins>PMEVCNTSVR&lt;n>_EL1</ins></a><ins> in the first range, the register is accessible from EL1, EL2, and EL3.</ins></p></li><li><del>The value returned by a direct read of MDCR_EL2.HPMN is </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del>.
</del></li><li><del>One of the following behaviors:</del><ul><li><del>An </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> number of counters are reserved for EL2 and EL3 use. That is, the PE behaves as if MDCR_EL2.HPMN is set to an </del><span class="arm-defined-word"><del>UNKNOWN</del></span><del> non-zero value less than or equal to </del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.N.
</del></li><li><del>All counters are reserved for EL2 and EL3 use, meaning no counters are accessible from EL1 and EL0.
</del></li></ul><p><ins>For an event counter snapshot register </ins><a href="AArch64-pmevcntsvrn_el1.html"><ins>PMEVCNTSVR&lt;n>_EL1</ins></a><ins> in the second range, the register is accessible from EL2 and EL3. If EL2 is disabled in the current Security state, the event counter is also accessible from EL1.</ins></p></li></ul><p><ins>Values greater than </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.N are reserved. If </ins><span class="xref"><ins>FEAT_HPMN0</ins></span><ins> is not implemented then the value 0 is reserved.</ins></p><p><del>When </del><span class="xref"><del>FEAT_PMUv3_SS</del></span><del> is implemented:</del></p><p><ins>If this field is set to a reserved value, then the following </ins><span class="arm-defined-word"><ins>CONSTRAINED UNPREDICTABLE</ins></span><ins> behaviors apply:</ins></p><ul><li><del>If HPMN is larger than </del><a href="AArch64-pmcr_el0.html"><del>PMCR_EL0</del></a><del>.N, or if </del><span class="xref"><del>FEAT_HPMN0</del></span><del> is not implemented and HPMN is 0, then the above </del><span class="arm-defined-word"><del>CONSTRAINED UNPREDICTABLE</del></span><del> behaviors apply.
</del></li><li><ins>The</ins><del>For</del> <ins>value</ins><del>a</del> <ins>returned</ins><del>snapshot</del> <ins>by</ins><del>register</del> <ins>a</ins><del>in</del> <ins>direct</ins><del>the</del> <ins>read</ins><del>first</del> <ins>of</ins><del>range,</del> <ins>MDCR_EL2.HPMN</ins><del>the</del> <del>register </del>is<del> accessible from EL1, EL2, and EL3.</del> <span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.
</ins></li><li><ins>Either:</ins><del>For a snapshot register in the second range, the register is accessible from EL2, and EL3.</del><ul><li><ins>An </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> number of counters are reserved for EL2 and EL3 use. That is, the PE behaves as if MDCR_EL2.HPMN is set to an </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> nonzero value less than or equal to </ins><a href="AArch64-pmcr_el0.html"><ins>PMCR_EL0</ins></a><ins>.N.
</ins></li><li><ins>All counters are reserved for EL2 and EL3 use, meaning no counters are accessible from EL1 and EL0 when EL2 is enabled in the current Security state.
</ins></li></ul></li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to the value in <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.N.</li></ul></div><h4 id="fieldset_0-4_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="access_mechanisms"><h2>Accessing MDCR_EL2</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, MDCR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.TDA == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = MDCR_EL2;
elsif PSTATE.EL == EL3 then
    X[t, 64] = MDCR_EL2;
                </p><h4 class="assembler">MSR MDCR_EL2, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0001</td><td>0b0001</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.TDA == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        MDCR_EL2 = X[t, 64];
elsif PSTATE.EL == EL3 then
    MDCR_EL2 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>16</ins><del>30</del>/<ins>12</ins><del>09</del>/2022 <ins>22</ins><del>15</del>:<ins>56</ins><del>58</del>; <ins>a71c0798221932a050ebb65b2030edfa84b9500f</ins><del>21c5a6dd0fdaf10a712e2f2d6fffbdbd66d4d96f</del></p><p class="copyconf">Copyright © 2010-2022 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>